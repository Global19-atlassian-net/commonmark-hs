{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE DeriveDataTypeable #-}

module Commonmark.Tokens
  ( Tok(..)
  , TokType(..)
  , tokenize
  , untokenize
  ) where

import           Data.Char       (isAlphaNum, isSpace)
import           Data.List       (mapAccumL)
import           Data.Text       (Text)
import qualified Data.Text       as T
import           Data.Data       (Data, Typeable)
import           Text.Parsec.Pos
import           Data.Attoparsec.Text
import           Control.Applicative
import           Control.Monad (mzero)

data Tok = Tok { tokType     :: TokType
               , tokPos      :: SourcePos
               , tokContents :: Text
               }
               deriving (Show, Eq, Data, Typeable)

data TokType =
       Spaces
     | UnicodeSpace
     | LineEnd
     | WordChars
     | Symbol !Char
     deriving (Show, Eq, Ord, Data, Typeable)

-- | Convert a 'Text' into a list of 'Tok'. The first parameter
-- species the source name.
tokenize :: String -> Text -> [Tok]
tokenize name t =
  case parseOnly (many tok) t of
    Right ts -> addSourcePos name ts
    Left err -> error $ "tokenizer failed: " ++ show err
                -- should never happen; if it does it's a programming error

tok :: Parser (TokType, Text)
tok = do
  mbc <- peekChar
  case mbc of
    Just ' '  -> (Spaces,) <$> takeWhile1 (== ' ')
    Just '\t' -> (Spaces,) <$> string "\t"
    Just '\r' -> (LineEnd,) <$> (string "\r\n" <|> string "\r")
    Just '\n' -> (LineEnd,) <$> string "\n"
    Just c
      | isAlphaNum c -> (WordChars,) <$> takeWhile1 isAlphaNum
      | isSpace c    -> (UnicodeSpace, T.singleton c) <$ anyChar
      | otherwise    -> (Symbol c, T.singleton c) <$ anyChar
    Nothing -> mzero

addSourcePos :: String -> [(TokType, Text)] -> [Tok]
addSourcePos name = snd . mapAccumL labelTok (initialPos name)

-- assumes t is nonempty, since this is generated by groupBy:
labelTok :: SourcePos -> (TokType, Text) -> (SourcePos, Tok)
labelTok pos (toktype, t) = (newpos, Tok toktype pos t)
  where
    newpos = case toktype of
        LineEnd       -> nextline
        Spaces
          | t == "\t" -> advancetab
          | otherwise -> advancecols
        WordChars     -> advancecols
        UnicodeSpace  -> nextcol
        Symbol _      -> nextcol
    nextline = setSourceColumn (incSourceLine pos 1) 1
    advancetab = incSourceColumn pos (4 - ((sourceColumn pos - 1) `mod` 4))
    advancecols = incSourceColumn pos (T.length t)
    nextcol = incSourceColumn pos 1

-- | Reverses 'tokenize'.  @untokenize . tokenize ""@ should be
-- the identity.
untokenize :: [Tok] -> Text
untokenize = mconcat . map tokContents
