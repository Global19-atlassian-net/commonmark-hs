{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE DeriveDataTypeable #-}

module Commonmark.Tokens
  ( Tok(..)
  , TokType(..)
  , tokenize
  , untokenize
  ) where

import           Data.Char       (isAlphaNum, isSpace)
import           Data.List       (mapAccumL)
import           Data.Text       (Text)
import qualified Data.Text       as T
import           Data.Data       (Data, Typeable)
import           Commonmark.ParserCombinators
                                 (SourcePos(..), initialPos,
                                  incSourceLine, incSourceColumn,
                                  HasSourcePos(..))

data Tok = Tok { tokType     :: TokType
               , tokPos      :: SourcePos
               , tokContents :: Text
               }
               deriving (Show, Eq, Data, Typeable)

data TokType =
       Spaces
     | UnicodeSpace
     | LineEnd
     | WordChars
     | Symbol !Char
     deriving (Show, Eq, Ord, Data, Typeable)

instance HasSourcePos Tok where
  tokenSourcePos = tokPos

-- | Convert a 'Text' into a list of 'Tok'. The first parameter
-- species the source name.
tokenize :: String -> Text -> [Tok]
tokenize name =
  snd . mapAccumL labelTok (initialPos name) . T.groupBy belongsWith
  where
    belongsWith ' ' ' ' = True
    belongsWith '\r' '\n' = True
    belongsWith x y
     | isAlphaNum x && isAlphaNum y = True
     | otherwise = False

-- assumes t is nonempty, since this is generated by groupBy:
labelTok :: SourcePos -> Text -> (SourcePos, Tok)
labelTok pos t =
  case c of
       '\r' -> (nextline, Tok LineEnd pos t)
       '\n' -> (nextline, Tok LineEnd pos t)
       '\t' -> (advancetab, Tok Spaces pos t)
       ' '  -> (advancecols, Tok Spaces  pos t)
       _ | isAlphaNum c -> (advancecols, Tok WordChars pos t)
         | isSpace c    -> (nextcol, Tok UnicodeSpace pos t)
         | otherwise    -> (nextcol, Tok (Symbol c)   pos t)
  where
    c = T.head t
    nextline = (incSourceLine pos 1){ sourceColumn = 1 }
    advancetab = incSourceColumn pos (4 - ((sourceColumn pos - 1) `mod` 4))
    advancecols = incSourceColumn pos (T.length t)
    nextcol = incSourceColumn pos 1

-- | Reverses 'tokenize'.  @untokenize . tokenize ""@ should be
-- the identity.
untokenize :: [Tok] -> Text
untokenize = mconcat . map tokContents
